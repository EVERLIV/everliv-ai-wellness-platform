
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { withRetry, isRetryableError } from '@/utils/retryUtils';

const SUPABASE_URL = "https://dajowxmdmnsvckdkugmd.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRham93eG1kbW5zdmNrZGt1Z21kIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDczMDk4MjIsImV4cCI6MjA2Mjg4NTgyMn0.G5VeyG16dUwl5IU98WEIxjWTSmlbPLoLuq6ZOiZxjeM";

// Clear any invalid tokens on initialization
const clearInvalidTokens = () => {
  try {
    const keys = Object.keys(localStorage);
    keys.forEach(key => {
      if (key.startsWith('sb-') && key.includes('auth-token')) {
        const token = localStorage.getItem(key);
        if (token && (token.includes('w435bqce2tys') || token.length < 10)) {
          console.log('Clearing invalid token:', key);
          localStorage.removeItem(key);
        }
      }
    });
  } catch (error) {
    console.error('Error clearing invalid tokens:', error);
  }
};

// Clear invalid tokens on client initialization
clearInvalidTokens();

// Create enhanced Supabase client with retry capabilities
const baseClient = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: window.localStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true
  },
  global: {
    headers: {
      'x-client-info': 'supabase-js-web'
    }
  },
  db: {
    schema: 'public'
  },
  realtime: {
    params: {
      eventsPerSecond: 10
    }
  }
});

// Создаем прокси для автоматической обработки ошибок и повторных попыток
const createRetryProxy = (client: any) => {
  return new Proxy(client, {
    get(target, prop) {
      const value = target[prop];
      
      if (prop === 'from') {
        return (table: string) => {
          const query = target.from(table);
          return createQueryProxy(query);
        };
      }
      
      if (prop === 'functions') {
        return {
          invoke: async (functionName: string, options?: any) => {
            return withRetry(
              () => target.functions.invoke(functionName, options),
              {
                maxAttempts: 3,
                baseDelay: 1000,
                retryCondition: isRetryableError
              }
            );
          }
        };
      }
      
      return value;
    }
  });
};

const createQueryProxy = (query: any) => {
  return new Proxy(query, {
    get(target, prop) {
      const value = target[prop];
      
      // Методы, которые выполняют запрос
      const executionMethods = [
        'select', 'insert', 'update', 'delete', 'upsert',
        'single', 'maybeSingle', 'csv', 'geojson'
      ];
      
      if (executionMethods.includes(prop as string) && typeof value === 'function') {
        return async function (...args: any[]) {
          const operation = () => value.apply(target, args);
          
          try {
            return await withRetry(operation, {
              maxAttempts: 3,
              baseDelay: 1000,
              retryCondition: isRetryableError
            });
          } catch (error) {
            console.error(`Supabase query failed after retries:`, error);
            throw error;
          }
        };
      }
      
      // Для методов построения запроса возвращаем новый прокси
      if (typeof value === 'function') {
        return function (...args: any[]) {
          const result = value.apply(target, args);
          return createQueryProxy(result);
        };
      }
      
      return value;
    }
  });
};

export const supabase = createRetryProxy(baseClient);
