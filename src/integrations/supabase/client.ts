// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { withRetry, isRetryableError } from '@/utils/retryUtils';

const SUPABASE_URL = "https://dajowxmdmnsvckdkugmd.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRham93eG1kbW5zdmNrZGt1Z21kIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDczMDk4MjIsImV4cCI6MjA2Mjg4NTgyMn0.G5VeyG16dUwl5IU98WEIxjWTSmlbPLoLuq6ZOiZxjeM";

// Clear any invalid tokens on initialization
const clearInvalidTokens = () => {
  try {
    // Check if localStorage is available
    if (typeof Storage === 'undefined' || !window.localStorage) {
      console.warn('localStorage is not available');
      return;
    }
    
    const keys = Object.keys(localStorage);
    keys.forEach(key => {
      if (key.startsWith('sb-') && key.includes('auth-token')) {
        const token = localStorage.getItem(key);
        if (token && (token.includes('w435bqce2tys') || token.length < 10)) {
          console.log('Clearing invalid token:', key);
          localStorage.removeItem(key);
        }
      }
    });
  } catch (error) {
    console.warn('localStorage access denied, continuing without token cleanup:', error.message);
  }
};

// Clear invalid tokens on client initialization
clearInvalidTokens();

// Create a safe storage wrapper
const createSafeStorage = () => {
  try {
    if (typeof Storage !== 'undefined' && window.localStorage) {
      return window.localStorage;
    }
  } catch (error) {
    console.warn('localStorage not available, using memory storage');
  }
  
  // Fallback to memory storage
  const memoryStorage: Storage = {
    length: 0,
    clear: () => {},
    getItem: () => null,
    key: () => null,
    removeItem: () => {},
    setItem: () => {}
  };
  return memoryStorage;
};

// Create enhanced Supabase client with retry capabilities
const baseClient = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: createSafeStorage(),
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true
  },
  global: {
    headers: {
      'x-client-info': 'supabase-js-web'
    }
  },
  db: {
    schema: 'public'
  },
  realtime: {
    params: {
      eventsPerSecond: 10
    }
  }
});

// Create a proxy that only wraps execution methods with retry logic
const createRetryProxy = (client: any) => {
  return new Proxy(client, {
    get(target, prop) {
      const value = target[prop];
      
      if (prop === 'from') {
        return (table: string) => {
          const query = target.from(table);
          return createQueryProxy(query);
        };
      }
      
      if (prop === 'functions') {
        return {
          invoke: async (functionName: string, options?: any) => {
            return withRetry(
              () => target.functions.invoke(functionName, options),
              {
                maxAttempts: 3,
                baseDelay: 1000,
                retryCondition: isRetryableError
              }
            );
          }
        };
      }

      // Return other properties as-is (auth, channel, removeChannel, etc.)
      return value;
    }
  });
};

const createQueryProxy = (query: any) => {
  return new Proxy(query, {
    get(target, prop) {
      const value = target[prop];
      
      // Query building methods - return new proxy for chaining
      const queryBuilderMethods = [
        'select', 'insert', 'update', 'delete', 'upsert',
        'eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'like', 'ilike', 
        'is', 'in', 'contains', 'containedBy', 'rangeGt', 'rangeGte',
        'rangeLt', 'rangeLte', 'rangeAdjacent', 'overlaps', 'textSearch',
        'match', 'not', 'or', 'filter', 'order', 'limit', 'range'
      ];
      
      // Execution methods - wrap with retry logic
      const executionMethods = [
        'single', 'maybeSingle', 'csv', 'geojson'
      ];
      
      if (typeof value === 'function') {
        if (queryBuilderMethods.includes(prop as string)) {
          return function (...args: any[]) {
            const result = value.apply(target, args);
            // Return proxy for continued chaining
            return createQueryProxy(result);
          };
        }
        
        if (executionMethods.includes(prop as string)) {
          return function (...args: any[]) {
            return withRetry(
              () => value.apply(target, args),
              {
                maxAttempts: 3,
                baseDelay: 1000,
                retryCondition: isRetryableError
              }
            ).catch(error => {
              console.error(`Supabase query failed after retries:`, error);
              throw error;
            });
          };
        }
        
        // For methods that might be execution methods (have .then)
        return function (...args: any[]) {
          const result = value.apply(target, args);
          
          // If result has .then, it's a promise (execution method)
          if (result && typeof result.then === 'function') {
            return withRetry(
              () => value.apply(target, args),
              {
                maxAttempts: 3,
                baseDelay: 1000,
                retryCondition: isRetryableError
              }
            ).catch(error => {
              console.error(`Supabase query failed after retries:`, error);
              throw error;
            });
          }
          
          // Otherwise, it's a query builder - return proxy
          return createQueryProxy(result);
        };
      }
      
      return value;
    }
  });
};

export const supabase = createRetryProxy(baseClient);
